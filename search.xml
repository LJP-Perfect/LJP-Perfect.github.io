<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[服务外包国赛总结]]></title>
    <url>%2F%E6%9C%8D%E5%8A%A1%E5%A4%96%E5%8C%85%E5%9B%BD%E8%B5%9B%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[&emsp;大二下本来是参加聂老师的机器学习的项目的，但是感觉自己学的零零碎碎，到最后也没有做出什么像样的成果。大二那个暑假，开始选导师了，聂老师还特地为我们几个组员留了位置，当时我觉得还是得先学一门扎实的语言可能对我的未来会有帮助一点，很不好意思的拒绝了聂老师的名额，去参加了孙老师带队的服务外包比赛。&emsp;那个学期，我才意识到原来我离保研虽然有挺大的距离，但是使劲够一够好像还能摸到边那种。也粗略的算了一下我的科研分，当时科研分还是0，必须得国赛、省赛都拿好名次，才能有机会加入保研队伍，感觉还可以再拼一拼。所以当时就向老师申请当国赛队长，然后就这么稀里糊涂地当上了队长。&emsp;第一次就当了国赛的队长，一开始真的很紧张，跟组员都不认识，自己交际能力还有点差。老师一开始的任务就是调研，我们的赛题是跨境电商，其实电商平台的业务逻辑就已经是很复杂了，再加上跨境，就真的很复杂复杂，而且现实中也很难有真实企业可以调研，后来几乎全是靠网上找资料。老师一开始让我们关注海关这一方面，但是这些东西之前从没了解过，网上的资料其实也不是很多，就只有几个其他平台供我们参考。第一轮调研下来，发现海关上面的可处理部分很少，都是交给第三方来处理的，所以那一周到两周的时间基本上算是走错了方向。后面又陆陆续续的做了些功能方面的调研和参考借鉴，现在回过头去看之前做的功能图和用例图，暂且先不说图画的怎么样，内容确实很单薄，考虑的东西太少了。&emsp;后面开始第二轮调研，我记得好像大二的几个同学从这里开始参与项目调研了，中间有个同学在这方面了解挺多的，讨论的东西就实际了很多，组员们讨论起来还是很积极的，跟我之前想的可能不太一样，这一轮调研下来收货还是很多的，基调也基本差不多定下来了。&emsp;接下来好像在考试周的时候开始进行代码工程了，当时我们组是只有一个前端，而且这个前端同学那个时候会议比较多，看得到进展很少，而且我们这个项目页面其实也不少，工作量还是很大的，好在后面老师也给我们做了调整，多加了一个前端同学，这样进度上有了一些保证。寒假大概留校两周，讲实话，做下来的进度比我想的要慢一点，所以我给他们寒假制定的计划相对较多吧，大概五天两到三个页面，给我自己也定了要基本完成的计划。为了控制好进度，我也让他们三天汇报一次完成情况，组员也都很给力，基本上每一阶段的任务都可以完成。（插入schedule图片）&emsp;我们那个群平时聊天频率很低，然而过年那天感觉都快炸了。那一天的聊天量估计是之前的总和差不多吧，哈哈哈。&emsp;寒假16号回来的，感觉进度很是比较快的，离提交项目还有一个月左右，所以也没有那么紧张。这个时间点我的心态就没有那么紧张了，跟组员交流的状态比之前轻松了许多。这一阶段我的代码工作没有那么大，把重心放在了文档和前端页面上。在这之前，word对我来说真的就像记事本差不多，除了标题改一下，其他什么也都不会，但我当时自己一个人负责文档的时候没有发现这么多问题，因为有之前的模板在，其实问题超级多。幸亏组里有个写文档比较厉害的二年级同学，在这期间，也真的学了好多word技术包括制作PPT的技术，对我后面的文档之类的工作有很大的帮助。在此之前，我可能只关注代码和技术，对这些软实力可能并不是很注重。&emsp;待更]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>竞赛</tag>
        <tag>服务外包</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First Vlog]]></title>
    <url>%2FFirst_Vlog.html</url>
    <content type="text"><![CDATA[第一次参加志愿者活动，去杭州图书馆做了三小时。一路上“偷偷”拍了些素材，然后哐哐哐哐剪出了第一个Vlog。Your browser does not support the video tag.]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>vlog</tag>
        <tag>杭州图书馆</tag>
        <tag>志愿者</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好，陈同学]]></title>
    <url>%2FNicetomeetyou.html</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务项目初步搭建]]></title>
    <url>%2Fcloud.html</url>
    <content type="text"><![CDATA[一个初步的微服务项目，docker部署。基于SpringBoot和SpringCloud整合Shiro、JWT、zuul、Eureka、docker、nginx等技术。项目简介这个小项目目前初步搭建好了微服务脚手架的一部分。使用shiro+jwt构建鉴权体系，spring cloud zuul做API网关进行路由转发，nginx通过反向代理对网关进行高可用和负载均衡和静态化，Eureka进行服务治理（Feign进行服务调用）。源码地址技术选型SpringBoot 2.0.4.RELEASESpringCloud Finchley.M9Shiro 1.4.0JWT 3.4.0Maven 3.5.4Jdk 8项目关键项目使用shiro+jwt的鉴权机制，通过JWTFilter将jwt整合到shiro，JWTToken存放用户名。JWTFilter部分代码@Override protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) { if(isLoginAttempt(request,response)){ try{ //检查token executeLogin(request,response); return true; }catch (Exception e){ //token错误 responseError(response,e.getMessage()); } } //请求头不存在Token，可能是未登录时（游客）的访问状态，则无需检查token return true; } shiro中添加JWTFilter，对所有之前（其他过滤器）未匹配到的请求进行过滤。ShiroConfig部分代码 @Bean public ShiroFilterFactoryBean shiroFilter(SecurityManager securityManager){ ShiroFilterFactoryBean filterFactoryBean=new ShiroFilterFactoryBean(); Map&lt;String, Filter> filterMap=new HashMap&lt;>(); filterMap.put("jwt",new JWTFilter()); filterFactoryBean.setFilters(filterMap); filterFactoryBean.setSecurityManager(securityManager); Map&lt;String,String> filterChainDefinitionMap=new HashMap&lt;>(); filterChainDefinitionMap.put("/logout","anon"); filterChainDefinitionMap.put("/login","anon"); filterChainDefinitionMap.put("/**","jwt"); filterFactoryBean.setLoginUrl("/login"); filterFactoryBean.setSuccessUrl("/index"); filterFactoryBean.setUnauthorizedUrl("/403"); filterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap); return filterFactoryBean; } 项目出现的BUG打包时，报缺少公共模块jar包的错误。公共模块不需要打包，所以不需要添加maven插件，否则会报错，因为其他模块在打包的时候会自动添加依赖进去，如果这里打包了，其他的模块就找不到该依赖了。父项目添加springboot的maven插件打包时会报Unable to find main class。[ERROR] Failed to execute goal org.springframework.boot:spring-boot-maven-plugin:2.0.4.RELEASE:repackage (default) on project common-util: Execu tion default of goal org.springframework.boot:spring-boot-maven-plugin:2.0.4.RELEASE:repackage failed: Unable to find main class 改成以下的编译和测试的maven插件，项目可以打包成功。这个问题还没有找到合理的解释方案，我想可能是因为spring-boot-maven-plugin要打包成可执行jar包，而公共模块里是没有启动类（main class）的，所以使用此插件会报错。&lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.apache.maven.plugins&lt;/groupId> &lt;artifactId>maven-compiler-plugin&lt;/artifactId> &lt;version>3.1&lt;/version> &lt;configuration> &lt;source>${java.version}&lt;/source> &lt;target>${java.version}&lt;/target> &lt;/configuration> &lt;/plugin> &lt;plugin> &lt;groupId>org.apache.maven.plugins&lt;/groupId> &lt;artifactId>maven-surefire-plugin&lt;/artifactId> &lt;version>2.19.1&lt;/version> &lt;configuration> &lt;skipTests>true&lt;/skipTests> &lt;!--默认关掉单元测试 --> &lt;/configuration> &lt;/plugin> &lt;/plugins> &lt;/build> 子模块的依赖中加入docker-maven-plugin的插件。此插件可以快速的打包镜像、上传镜像等。最好加入spring-boot-maven-plugin插件，我记得打包过程中出现过问题就是缺少这个插件的原因（好像是空指针异常，记不太清了）。&lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;/plugin> &lt;plugin> &lt;groupId>com.spotify&lt;/groupId> &lt;artifactId>docker-maven-plugin&lt;/artifactId> &lt;version>1.0.0&lt;/version> &lt;executions> &lt;execution> &lt;id>build-image&lt;/id> &lt;phase>package&lt;/phase> &lt;goals> &lt;goal>build&lt;/goal> &lt;/goals> &lt;/execution> &lt;/executions> &lt;configuration> &lt;imageName>${project.parent.artifactId}/${project.artifactId}&lt;/imageName> &lt;dockerHost> http://192.168.43.2:2375&lt;/dockerHost> &lt;dockerDirectory>${project.basedir}&lt;/dockerDirectory> &lt;resources> &lt;resource> &lt;targetPath>/&lt;/targetPath> &lt;directory>${project.build.directory}&lt;/directory> &lt;include>${project.build.finalName}.jar&lt;/include> &lt;/resource> &lt;/resources> &lt;/configuration> &lt;dependencies> &lt;dependency> &lt;groupId>org.apache.httpcomponents&lt;/groupId> &lt;artifactId>httpclient&lt;/artifactId> &lt;version>4.5.6&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>javax.activation&lt;/groupId> &lt;artifactId>activation&lt;/artifactId> &lt;version>1.1.1&lt;/version> &lt;/dependency> &lt;/dependencies> &lt;/plugin> &lt;/plugins> &lt;/build> docker不能使用localhost因为 bridge 是 Docker 默认的网络模式，换句话说，我一个 host 上的各个 container 从 docker 获取的 IP 都是不一样的（在主机编译部署后大家都是 localhost，但是在 docker 里面情况就不一样了）。解决方法利用docker的主机名，为eureka的容器配置一个主机名（任意即可），比如eureka-server。eureka-server模块配置文件eureka: client: fetch-registry: false register-with-eureka: false service-url: defaultZone: http://eureka-server:8000/eureka/ eureka-client模块配置文件eureka: client: service-url: defaultZone: http://eureka-server:8000/eureka/ 整合shiro出现No bean of type ‘org.apache.shiro.realm本来是把shiro的一些配置和JWTToken类这些放到公共模块中。但是一直报如上错误，提示我创建shiro.ini，但是这样的话采用硬编码方式把认证授权信息写在INI文件中,可维护性差。没办法，只能把shiro有关的配置和LoginController放在一个模块中。zuul会过滤敏感头部，导致丢失token。zuul会过滤掉Cookie, Set-Cookie, Authorization的header信息，导致jwt的token在转发时丢失。在ZuulProperties源码中可以看到默认的sensitiveHeaders如下。（如果头部出现含有sensitiveHeaders的信息，就不会添加到转发的请求中）private Set&lt;String> sensitiveHeaders = new LinkedHashSet(Arrays.asList("Cookie", "Set-Cookie", "Authorization")); 只要修改zuul的sensitiveHeaders配置即可。设置为空，设置为空，设置为空。zuul: sensitive-headers: nginx的http模块。我只要在nginx配置文件加入http{}，就会报“http&quot; directive is not allowed here in /etc/nginx/conf.d/app.conf错误。真的是个谜之错误，-_-。参考资料Spirng boot maven多模块打包踩坑Spring Cloud实战小贴士：Zuul处理Cookie和重定向gitee项目 micro-serviceexception is feign.RetryableException: Connection refused (Connection refused) executing GET http：//……]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>SpringCloud</tag>
        <tag>Shiro</tag>
        <tag>Nginx</tag>
        <tag>JWT</tag>
        <tag>Docker</tag>
        <tag>Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的技能树（惨不忍睹）]]></title>
    <url>%2Ffreetalk.html</url>
    <content type="text"><![CDATA[网上有很多文章都有这张图片，名为“2018Web开发需要掌握的技能”，正好自己在学习这一方面，所以想要看看自己都会点什么。&nbsp;Java 多线程掌握比较差、JVM还没了解过WebServerNginx 看到它只知道负载均衡，稍微有点了解RESTful APIs 据我所知使用GET、PUT、DELETE、POST请求方式来简化APIAUthenticationJWT 了解过一点，原理不是很懂，未实践过OAuth 2.0 未了解过❌Docker 基本部署可以实现Message BrokersRabbitMQ 未了解过❌Apache Kafka 未了解过❌CachingMemcached 未了解过❌Redis 可以实现缓存，但是数据结构学了就忘了DatabasesMySQL Sql优化不会MongoDB 未了解过❌ElasticSearch 未了解过❌GOF Design Patterns 只会单例模式、工厂模式好像又忘了Architectural Patterns 未了解过❌Give DDD a shot 未了解过❌Learn different testing techniques 了解过Mocking，其他不知道&nbsp;列出来后发现自己都停留在无脑调用接口，只会表面，对于深层的实现和原理都不怎么懂。而且有这么多叉叉都没了解过。少年不能浪费时间了，快醒醒啊！争取把这些都变成绿勾勾！！！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>技能树</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次惨痛的Docker部署SpringBoot经历]]></title>
    <url>%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%83%A8%E7%97%9B%E7%9A%84Docker%E9%83%A8%E7%BD%B2SpringBoot.html</url>
    <content type="text"><![CDATA[环境SpringBoot 2.0.4.RELEASEDocker 18.06.1-ceUbuntu 16.04Jdk 8Maven 3.5.4搭建SpringBoot项目导入web依赖，编写一个简单的Controller。然后添加Docker支持。&lt;!--docker maven 插件--> &lt;plugin> &lt;groupId>com.spotify&lt;/groupId> &lt;artifactId>docker-maven-plugin&lt;/artifactId> &lt;version>1.0.0&lt;/version> &lt;configuration> &lt;imageName>${project.artifactId}&lt;/imageName> &lt;!--注意 修改成远程服务器地址--> &lt;dockerHost> http://192.168.43.2:2375&lt;/dockerHost> &lt;dockerDirectory>src/main/docker&lt;/dockerDirectory> &lt;resources> &lt;resource> &lt;targetPath>/&lt;/targetPath> &lt;directory>${project.build.directory}&lt;/directory> &lt;include>${project.build.finalName}.jar&lt;/include> &lt;/resource> &lt;/resources> &lt;/configuration> &lt;dependencies> &lt;dependency> &lt;groupId>org.apache.httpcomponents&lt;/groupId> &lt;artifactId>httpclient&lt;/artifactId> &lt;version>4.5.6&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>javax.activation&lt;/groupId> &lt;artifactId>activation&lt;/artifactId> &lt;version>1.1.1&lt;/version> &lt;/dependency> &lt;/dependencies> &lt;/plugin> 需要javax.activation依赖，不然会报java.lang.ClassNotFoundException: javax.activation.DataSource错误。环境配置好后，编写DockerfileFROM openjdk:8-jdk-alpine VOLUME /opt/common ADD dockerdemo-1.0.jar app.jar ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/app.jar"] EXPOSE 8080 VOLUME ，VOLUME 指向了一个/opt/common的目录，由于 Spring Boot 使用内置的Tomcat容器，Tomcat 默认使用/opt/common作为工作目录。这个命令的效果是：在宿主机的/var/lib/docker目录下创建一个临时文件并把它链接到容器中的/opt/common目录ADD ，拷贝文件并且重命名ENTRYPOINT ，为了缩短 Tomcat 的启动时间，添加java.security.egd的系统属性指向/dev/urandom作为 ENTRYPOINT这里可以安装一款Docker integration插件，可以构建镜像，创建仓库，上传镜像等。安装这个插件后，Dockerfile文件就能显示语法了。其他功能暂时没用到。配置虚拟机环境配置Jdk 8 $ sudo apt-get update $ sudo apt-get install openjdk-8-jdk 使用java -version查看是否安装成功。然后配置jdk环境变量sudo gedit /etc/profile export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH source /etc/profile 配置Maven下载：http://mirrors.shu.edu.cn/apache/maven/maven-3/3.5.4/binaries/apache-maven-3.5.4-bin.tar.gz## 解压 tar vxf apache-maven-3.5.4-bin.tar.gz ## 移动 mv apache-maven-3.5.4 /usr/local/maven3 仍然是在/etc/profile中配置环境变量sudo gedit /etc/profile MAVEN_HOME=/usr/local/maven3 export MAVEN_HOME export PATH=${PATH}:${MAVEN_HOME}/bin source /etc/profile 构建、上传、运行镜像使用docker build插件可以快速构建。也可以在Terminal输入以下命令进行构建。mvn package docker:build 构建成功后，就可以在docker中使用docker images查看镜像。REPOSITORY TAG IMAGE ID CREATED SIZE dockerdemo latest 2d6bfc475fa7 44 hours ago 119MB 运行该镜像docker run -p 8080:8080 -t dockerdemo 运行成功后测试Controller是否成功即可。遇到的问题1、docker构建镜像报错org.apache.http.conn.ConnectTimeoutException:contact timed out如果之前没有配置过Docker的远程访问，那么应该是这个原因。开启API访问服务：$ systemctl show --property=FragmentPath docker FragmentPath=/lib/systemd/system/docker.service $ sudo gedit /lib/systemd/system/docker.service #修改ExecStart=/usr/bin/dockerd -H fd:// 为 ExecStart=/usr/bin/dockerd -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375 #重载Docker $ sudo systemctl daemon-reload $ sudo systemctl restart docker docker -H tcp://127.0.0.1:2376 version Client: Version: 18.06.1-ce API version: 1.38 Go version: go1.10.3 Git commit: e68fc7a Built: Tue Aug 21 17:24:56 2018 OS/Arch: linux/amd64 Experimental: false Server: Engine: Version: 18.06.1-ce API version: 1.38 (minimum version 1.12) Go version: go1.10.3 Git commit: e68fc7a Built: Tue Aug 21 17:23:21 2018 OS/Arch: linux/amd64 Experimental: false 这样就说明API远程访问已开启。也可通过以下方法验证ps -ef | grep docker 可以看到2375端口已经在监听了。再进行测试查看是否成功。但是还是报了这个错误，网上找了很多没有类似问题，最后找到一个有类似问题的，不过他是将服务器部署到阿里云上的，是因为阿里云控制台里的安全组没有开启2375端口。Docker Maven插件本地构建镜像发布至远程服务器但是我这个是本地的，所以没有效果。只好重装了Ubuntu，意外的成功了，猜想可能是之前的Ubuntu或Docker的配置导致了这个错误。2、报错java.lang.ClassNotFoundException: javax.activation.DataSource是因为docker maven插件缺少javax.activation依赖，加入以下依赖&lt;dependency> &lt;groupId>javax.activation&lt;/groupId> &lt;artifactId>activation&lt;/artifactId> &lt;version>1.1.1&lt;/version> &lt;/dependency> 3、报错Add failed: stat /ver/lib/docker/tmp/docker-builderXXXXXX:no such file or dir报这个错误是因为打包名字不一致，pom.xml的artifactId与Dockerfile镜像名要一致。&nbsp;要是怎么样都不行，重装吧少年!&nbsp;参考资料Spring Boot 2.0(四)：使用 Docker 部署 Spring Bootdocker开启远程访问Docker Maven插件本地构建镜像发布至远程服务器4、为什么使用docker?之Docker建立远程连接]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Docker</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github代码上传]]></title>
    <url>%2Fgithub%E4%BB%A3%E7%A0%81%E4%B8%8A%E4%BC%A0.html</url>
    <content type="text"><![CDATA[$ git init$ git add .$ git commit -m &quot;first commit&quot;$ git remote add origin https://github.com/yourName/yourRepo.git$ git push -u origin master#上传多个项目到一个仓库$ git add .$ git commit -m &quot;second commit&quot;$ git push -u origin master#push失败,本地与仓库不一致，先pull下来$ git pull --rebase origin master$ git push -u origin master]]></content>
      <categories>
        <category>技术杂烩</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis作为Mybatis辅存]]></title>
    <url>%2Fredis%E4%BD%9C%E4%B8%BA%E8%BE%85%E5%AD%98.html</url>
    <content type="text"><![CDATA[Q&amp;A个人思考Q1：为什么要用redis作为mysql的辅存？A：与数据库的交互无非读和写。在读这一方面，数据的访问一般来说都不是平均的，有些数据经常被访问称为“热数据”，还有一些不会经常访问到的则称为冷数据。如果要在这里优化，第一感觉肯定是去优化热数据的读取速度，和计算机组成原理学的缓存一样，越靠近CPU的Cache读写速度越快，所以我觉得在读取时可以先去访问redis，没有再去数据库里查找。然后就是写这一方面，可能瞬间写的压力非常大，造成拥挤甚至可能系统出错。因为在写的速度方面redis应该是优于直接写入数据库的，所以可以先写入redis，然后再慢慢写入数据库。这样一来，对写的压力减少了一些，但是数据的同步问题出现了。Q2：那为什么选择redis还不是其他的工具？A：emm…我觉得这个问题只能先留着吧，其他也都没学过。注：以上纯属个人想法，不一定都是正确的。查阅一番资料后因为redis是存储在内存中，mysql是存储在硬盘中，redis的读取速度比直接读取mysql快很多，所以一般用于热数据的读取，不适合数据高一致性（直接操作Mysql，就不要考虑用redis速度快的特性来写数据）。如果使用redis作为缓存的话，先去redis中判断数据是否存在，如果存在，则直接返回redis中的数据。不存在的话，就会去数据库中读取并缓存到redis中。同时Redis支持数据的持久化，服务器关闭重启后可以重新加载。有两种持久化方式：快照（RDB文件）和追加式文件（AOF文件）。RDB持久化方式会在一个特定的间隔保存那个时间点的一个数据快照，AOF方式会记录每一个写操作。在服务启动时，这些记录会被逐条执行重建原来的数据。（默认情况下，AOF被优先使用）Redis自动进行热数据缓存：方案一、设置ExpiredTime，如果访问频繁的数据生存时间会一直更新，冷数据如果不再次访问的话，就会在指定时间内过期清除掉，间接实现热数据缓存。两种方式实现Redis缓存一、全局实现Redis缓存1、导入依赖&lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-data-redis&lt;/artifactId> &lt;/dependency> 2、重写org.apache.ibatis.cache.Cache//使用redisTemplate的对应方法重写Cache的方法 public class RedisCache implements Cache { private static final Logger logger = LoggerFactory.getLogger(RedisCache.class); //实例一个读写锁 private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); private final String id; // cache instance id private RedisTemplate redisTemplate; private static final long EXPIRE_TIME_IN_MINUTES = 30; // redis过期时间 //必须要有一个初始化id的构造器 public RedisCache(String id) { if (id == null) { throw new IllegalArgumentException("Cache instances require an ID"); } this.id = id; } @Override public String getId() { return id; } /** * Put query result to redis * * @param key * @param value */ @Override @SuppressWarnings("unchecked") public void putObject(Object key, Object value) { try { RedisTemplate redisTemplate = getRedisTemplate(); ValueOperations opsForValue = redisTemplate.opsForValue(); opsForValue.set(key, value, EXPIRE_TIME_IN_MINUTES, TimeUnit.MINUTES); logger.debug("Put query result to redis"); } catch (Throwable t) { logger.error("Redis put failed", t); } } /** * Get cached query result from redis * * @param key * @return */ @Override public Object getObject(Object key) { try { RedisTemplate redisTemplate = getRedisTemplate(); ValueOperations opsForValue = redisTemplate.opsForValue(); logger.debug("Get cached query result from redis"); return opsForValue.get(key); } catch (Throwable t) { logger.error("Redis get failed, fail over to db", t); return null; } } /** * Remove cached query result from redis * * @param key * @return */ @Override @SuppressWarnings("unchecked") public Object removeObject(Object key) { try { RedisTemplate redisTemplate = getRedisTemplate(); redisTemplate.delete(key); logger.debug("Remove cached query result from redis"); } catch (Throwable t) { logger.error("Redis remove failed", t); } return null; } /** * Clears this cache instance */ @Override public void clear() { RedisTemplate redisTemplate = getRedisTemplate(); redisTemplate.execute((RedisCallback) connection -> { connection.flushDb(); return null; }); logger.debug("Clear all the cached query result from redis"); } /** * This method is not used * * @return */ @Override public int getSize() { return 0; } @Override public ReadWriteLock getReadWriteLock() { return readWriteLock; } private RedisTemplate getRedisTemplate() { if (redisTemplate == null) { //若redisTemplate不存在，则从ApplicaitonContext取出redisTemplate redisTemplate = SpringContextHolder.getBean("redisTemplate"); } return redisTemplate; } } 3、CMS层省略不放进文章里了，开始测试第一次根据UserName查询User可以看到Cache Hit Ratio 为0，说明在Redis中没有对应的缓存，所以从数据库中查询数据。在RedisDesktopManager可以看到已经存入一个序列化数据。第二次查询就可以看到Cache Hit Ratio为1.0，并且没有查询数据库的日志消息，说明此次查询是从Redis获取的数据。二、使用注解来使用Redis缓存1、构造fastjson序列化器需要另外导入fastjson依赖&lt;dependency> &lt;groupId>com.alibaba&lt;/groupId> &lt;artifactId>fastjson&lt;/artifactId> &lt;version>1.2.31&lt;/version> &lt;/dependency> 配置FastJsonRedisSerializerpublic class FastJsonRedisSerializer&lt;T> implements RedisSerializer&lt;T> { private static final Charset DEFAULT_CHARSET = Charset.forName("UTF-8"); private Class&lt;T> clazz; public FastJsonRedisSerializer(Class&lt;T> clazz) { this.clazz = clazz; //fastjson1.2.25版本之后，需要开启AutoTypeSupport //否则从redis缓存中读取的数据会报autoType is not support.错误。 ParserConfig.getGlobalInstance().setAutoTypeSupport(true); } //重写序列化方法 @Override public byte[] serialize(T t) throws SerializationException { if (t == null) { return new byte[0]; } return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET); } //重写反序列化方法 @Override public T deserialize(byte[] bytes) throws SerializationException { if (bytes == null || bytes.length &lt;= 0) { return null; } String str = new String(bytes, DEFAULT_CHARSET); return (T) JSON.parseObject(str, clazz); } } 配置完序列化器后，再配置Redis缓存的相关配置。@Configuration @EnableCaching public class RedisCacheConfig { @Bean public RedisTemplate&lt;Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) { RedisTemplate&lt;Object, Object> template = new RedisTemplate&lt;>(); template.setConnectionFactory(redisConnectionFactory); //因为SpringBoot整合的最新的redis中的CacheManager是没有RedisTemplate的构造方法的。 //所以似乎在RedisTemplate设置Key和Value的序列器是无效的（实践过确实如此） //但是在此设置之后，在cacheManager配置时也可以从redisTemplate中取出来 FastJsonRedisSerializer&lt;Object> serializer=new FastJsonRedisSerializer&lt;>(Object.class); template.setValueSerializer(serializer); //使用StringRedisSerializer来序列化和反序列化redis的key值 template.setKeySerializer(new StringRedisSerializer()); template.afterPropertiesSet(); return template; } /*配置缓存管理器 *如果配置自己定义的序列化器，要传RedisTemplate进来。或者在里面重新实例序列化器，这里使用前者的方式 */ @Bean public CacheManager cacheManager(RedisConnectionFactory redisConnectionFactory,RedisTemplate redisTemplate) { // 生成一个默认配置，通过config对象即可对缓存进行自定义配置 // serialzeValuesWith方法会重新实例化RedisCacheConfiguration，所以在生成配置时，不能分开配置，只能进行链式配置 RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(redisTemplate.getValueSerializer())) .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisTemplate.getKeySerializer())); config = config.entryTtl(Duration.ofMinutes(1)) // 设置缓存的默认过期时间，也是使用Duration设置 .disableCachingNullValues(); // 不缓存空值 // 设置一个初始化的缓存空间set集合 Set&lt;String> cacheNames = new HashSet&lt;>(); cacheNames.add("user"); Map&lt;String, RedisCacheConfiguration> configMap = new HashMap&lt;>(); configMap.put("user", config.entryTtl(Duration.ofSeconds(120))); RedisCacheManager cacheManager = RedisCacheManager.builder(redisConnectionFactory) // 使用自定义的缓存配置初始化一个cacheManager .initialCacheNames(cacheNames) // 注意这两句的调用顺序，一定要先调用该方法设置初始化的缓存名，再初始化相关的配置 .withInitialCacheConfigurations(configMap) .build(); return cacheManager; } } 然后在需要缓存的地方加上@Cacheable注解即可，unless表示如果结果为空则不进行缓存@Cacheable(value = "user", key = "#root.targetClass + #name", unless = "#result eq null") 进行测试查询，第一次仍然是去访问数据库，第二次是从redis缓存中查到的。参考资料SpringBoot2整合Redis缓存Redis持久化_segmentfault有没有方法让redis 自动做热数据缓存？]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot2.0.4配置hystrix-dashboard，出现Unable to connect to Command Metric Stream错误]]></title>
    <url>%2Fhystrix_dashboard.html</url>
    <content type="text"><![CDATA[配置Hystrix-dashboard后进入监控页面出现Unable to connect to Command Metric Stream。本来还以为配置监控面板应该是件比较简单的事情，没想到被SpringBoot版本坑了。当前的SpringBoot版本为2.0.4.RELEASE，SpringCloud版本为Finchley.M9。新建一个hystrix_dashboard模块，导入相应的依赖spring-cloud-starter-netflix-hystrix-dashboard。在Main启动类上加上@EnableHystrixDashboard注解，配置文件配置一下端口和应用名即可。并且在消费模块配置actuator依赖。这时打开dashboard输入URL后就是下面这个样子。&nbsp;找了很多解决方案，才发现是actuator版本问题。actuator的2.x版本endpoint是在/actuator之下的，并且只暴露了health和info端点。详细文档点我 所以需要为服务实例添加hystrix.stream端点。management: endpoints: web: exposure: include: ['hystrix.stream','info','health'] 此时重启后发现日志输出Registered ‘/actuator/hystrix.stream’ to hystrix.stream-actuator-endpoint再输入http: //localhost:8100/actuator/hystrix.stream就发现可以进行监控了。如下图：&nbsp;如果想直接通过http: //localhost:8100/hystrix.stream，只需要配置端点的base-path即可management: endpoints: web: base-path: / 理论上修改base-path应该就可行了的，但是又出错了。哎，又不知道是哪里的问题，先留着吧！贴一张hystrix-dashboard界面各部分介绍图：]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>报错</tag>
        <tag>Hystrix-dashboard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot2.0.4配置Eureka出现Unable to start embedded Tomcat错误]]></title>
    <url>%2Feureka.html</url>
    <content type="text"><![CDATA[导入依赖官网版本对应的描述与SpringBoot 2.x版本兼容的SpringCloud版本为Finchley2.0.4版本pom依赖为spring-cloud-starter-netflix-eureka-server(以后查询所需依赖去官网查)但是导入依赖后遇到的了无法启动内置Tomcat的问题？jdk版本问题，jaxb的依赖问题，JAXB API是java EE 的API，因此在java SE 9.0 中不再包含这个 Jar 包。 java 9 中引入了模块的概念，默认情况下，Java SE中将不再包含java EE 的Jar包 而在 java 6/7/8 时关于这个API 都是捆绑在一起的。所以导入jaxb-core、jaxb-api、jaxb-impl、activation四个jar包即可，或者导入jdk8。注：IDEA内置的jdk8也会报这个错误，只能使用自己另外安装的jdk8。pom.xml完整文件&lt;?xml version="1.0" encoding="UTF-8"?> &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;groupId>me.freelee&lt;/groupId> &lt;artifactId>springcloud_eureka&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;packaging>jar&lt;/packaging> &lt;name>springcloud_eureka&lt;/name> &lt;description>Demo project for Spring Boot&lt;/description> &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>2.0.4.RELEASE&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> &lt;properties> &lt;project.build.sourceEncoding>UTF-8&lt;/project.build.sourceEncoding> &lt;project.reporting.outputEncoding>UTF-8&lt;/project.reporting.outputEncoding> &lt;java.version>1.8&lt;/java.version> &lt;spring-cloud.version>Finchley.M9&lt;/spring-cloud.version> &lt;/properties> &lt;dependencies> &lt;dependency> &lt;groupId>com.sun.xml.bind&lt;/groupId> &lt;artifactId>jaxb-core&lt;/artifactId> &lt;version>2.2.11&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>javax.xml.bind&lt;/groupId> &lt;artifactId>jaxb-api&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>com.sun.xml.bind&lt;/groupId> &lt;artifactId>jaxb-impl&lt;/artifactId> &lt;version>2.2.11&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.glassfish.jaxb&lt;/groupId> &lt;artifactId>jaxb-runtime&lt;/artifactId> &lt;version>2.2.10-b140310.1920&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>javax.activation&lt;/groupId> &lt;artifactId>activation&lt;/artifactId> &lt;version>1.1.1&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-netflix-eureka-server&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;/dependencies> &lt;dependencyManagement> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-dependencies&lt;/artifactId> &lt;version>${spring-cloud.version}&lt;/version> &lt;type>pom&lt;/type> &lt;scope>import&lt;/scope> &lt;/dependency> &lt;/dependencies> &lt;/dependencyManagement> &lt;repositories> &lt;repository> &lt;id>spring-milestones&lt;/id> &lt;name>Spring Milestones&lt;/name> &lt;url>https://repo.spring.io/libs-milestone&lt;/url> &lt;snapshots> &lt;enabled>false&lt;/enabled> &lt;/snapshots> &lt;/repository> &lt;/repositories> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/project> &nbsp;参考资料:解决方案解决方案中文]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Eureka</tag>
        <tag>报错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker学习笔记]]></title>
    <url>%2Fdocker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[Docker与虚拟机Docker是Client-Server结构。虚拟机技术通过Hypervisor层抽象底层基础设施资源，提供相互隔离的虚拟机，通过统一配置、统一管理，计算资源的可运维性，以及资源利用率都能够得到有效的提升。同时，虚拟机提供客户机操作系统，客户机变化不会影响宿主机，能够提供可控的测试环境，更能够屏蔽底层硬件甚至基础软件的差异性，让应用做到的广泛兼容。然而，再牛逼的虚拟化技术，都不可避免地出现计算、IO、网络性能损失，毕竟多了一层软件，毕竟要运行一个完整的客户机操作系统。容器技术严格来说并不是虚拟化，没有客户机操作系统，是共享内核的。容器可以视为软件供应链的集装箱，能够把应用需要的运行环境、缓存环境、数据库环境等等封装起来，以最简洁的方式支持应用运行，轻装上阵，当然是性能更佳。Docker镜像特性则让这种方式简单易行。当然，因为共享内核，容器隔离性也没有虚拟机那么好。服务器虚拟化解决的核心问题是资源调配，而容器解决的核心问题是应用开发、测试和部署。镜像命令docker info 查看docker信息详情docker images 列出本地镜像，同一仓库源可以有多个Tag（版本），使用Repository：Tag选择不同版本&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;–no-trunc 全部信息docker rmi 镜像名 删除镜像&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-f 强制删除Docker history 镜像名 列出镜像的变更历史容器命令docker run [OPTIONS] image [COMMAND] 新建并启动容器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OPTIONS：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;–name=“New Name” 指定容器新名字&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-d 后台运行容器，并返回容器ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-i 以交互模式运行容器，通常与-t使用（-it）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-t 为容器重新分配一个输入终端&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-P 随机分配端口映射&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-p 指定端口映射（主机端口：容器端口）docker ps [OPTIONS] 列出所有正在运行的容器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OPTIONS:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-a 列出正在运行的 + 历史运行过的&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-q 静默模式，只显示容器编号docker start/restart/stop 容器名/容器ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kill 强制删除&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rm 容器ID 删除已停止容器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rm -f $(docker ps -a -q) 删除所有容器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rmi 镜像名docker logs -f -t –tail 容器ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-f 跟随最新的日志打印&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;–tail 数字 显示最后指定的条数docker top 容器ID 查看容器内运行的进程docker inspect 容器ID 查看容器内部细节exit 停止并退出容器Ctrl+P+Q 不停止退出容器docker attach ID 进入容器，不新建进程docker exec -t ID ls -l /tmp /bin/bash 直接打印返回结果docker cp 容器ID：容器内路径 目的主机路径 把文件从容器拷贝到主机docker commit -m=”描述” -a=”作者” 容器ID 新镜像名:[标签名] 提交修改后容器生成新的镜像Docker容器数据卷容器的持久化、容器间继承+共享数据数据卷：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容器内添加：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接添加：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;docker run -it -v /宿主机绝对路径目录：/容器内目录 镜像名&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容器停止退出后，主机修改数据可以同步&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;权限：docker run -it -v /宿主机绝对路径目录：/容器内目录：ro 镜像名 数据只读&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dockerfile添加：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）编写Dockerfile文件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）docker build -f 目录/Dockerfile -t freelee/镜像名 构建镜像&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）Docker会默认指定主机数据卷地址（可通过inspect命令查看）数据卷容器：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;挂载数据卷的容器，其他容器通过挂载这个（父容器）实现数据共享。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容器间传递共享：docker run -it –name dc02 –volumes-from dc01 freelee/centos&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;删除父容器后，原数据不会丢失。子容器依旧可以共享数据，数据卷生命周期一直到没有容器使用它为止DockerfileDockerfile是用来构建Docker镜像的构建文件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）每条指令保留字必须大写且后跟参数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）从上到下，顺序执行&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）每条指令都会创建一个新的镜像层，并对镜像进行提交指令：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FROM 基础镜像&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MAINTER 作者和邮箱&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RUN 构建时需要执行的命令&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EXPOSE 暴露的端口号&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WORKDIR 工作目录&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ENV 构建过程中设置环境变量&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ADD 将宿主机目录下文件拷贝进镜像且ADD命令会自动处理URL和解压tar包&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VOLUMN 容器数据卷&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CMD 容器运行时执行的命令，最后一个命令会覆盖前面&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ENTRYPOINT 容器运行时执行的命令，后面的命令会叠加在后面&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ONBUILD 继承此镜像的子镜像在构建时会触发Dockerfile案例案例一：原始centos进入镜像默认路径为 / ，且不支持vim编辑器和查看网络配置ifconfigFROM centos ENV mypath /tmp WORKDIR $mypath RUN yum -y install vim RUN yum -y install net-tools EXPOSE 80 CMD /bin/bash 案例二：ONBUILD指令FROM centos RUN yum install -y curl ENTRYPOINT ["curl","-s","http://ip.cn"] ONBUILD RUN echo "father image onbuild......" &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;知乎上网易云关于Docker和虚拟机的回答]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>学习笔记</tag>
        <tag>Dockerfile</tag>
        <tag>容器数据卷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络学习记录]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html</url>
    <content type="text"><![CDATA[大二下学期开过这门课，当时因为课时原因大概只讲到DNS，而且很多都忘了，现在再复习一遍以此记录。课程学习视频：哈尔滨工业大学 计算机网络课程视频参考书籍：《计算机网络》（第七版）物理层信道复用技术（2018.09.21）为什么有信道复用技术？传统信息传输是单对单进行的，如果用户不使用的话就会空闲，信道利用率将会很低。因此提出了复用概念，但是这里又有一个问题，多个用户如果同时使用，信道的传输的信息岂不是乱了套？！接着有了以下几种主要复用技术。频分复用：用户分配到一定的频带，不同的用户再不用的频带上进行传输时不会相互干扰，常见应用就是有线电视，遥控板其实就是调频来换台。波分复用：跟频分复用类似，只不过是在光波中进行不同的波长传输（也就是不同的频率）。时分复用：将时间分片，用户分配到不同的时间片进行传输。码分复用：码分复用比较复杂一点，详细介绍一下实现原理。定义：“码分复用是用一组包含互相正交的码字的码组携带多路信号”不同的站分配到不同的唯一的m bit的码片序列，且须相互正交，这样才能抵抗干扰。$$内积公式： S·T=\frac {1}{m} \sum_{i=1}^m S_iT_i=0$$举个例子：假设有两个站S和T，设站S的码片序列为（-1 -1 -1 +1 +1 -1 +1 +1），站T的码片序列为（-1 -1 +1 -1 +1 +1 +1 -1），内积计算可得这两个码片序列结果为0。注：然后我们通常指定传输比特1就是1，发送比特0时为-1（运用了正交的特性）。假设S站发送了数据是1即（-1 -1 -1 +1 +1 -1 +1 +1），T发送的数据也是1即（-1 -1 +1 -1 +1 +1 +1 -1）。叠加后就是（-1 -1 -1 +1 +1 -1 +1 +1）+（-1 -1 +1 -1 +1 +1 +1 -1）接收方如果是使用S站的码片序列，那么经过以下计算：（-1 -1 -1 +1 +1 -1 +1 +1）·（（-1 -1 -1 +1 +1 -1 +1 +1）+（-1 -1 +1 -1 +1 +1 +1 -1））=1+0=1，就是S发送的数据。因为T站和S站码片序列正交，所以使用T发送的数据不管和S发送的数据如果叠加，其内积结果都是0。这样就是实现不同用户之间的信号不混乱。应用层超文本传送协议HTTP（2018.09.23）定义HTTP协议定义了浏览器如何向万维网服务器请求万维网文档，以及服务器如何把文档传送给浏览器。是应用层的一个协议使用了TCP协议来保证数据的可靠传输，毫无疑问它是互联网通信的基础。工作过程一开始，客户端向服务器端发送TCP连接的请求，服务器端默认在80端口监听客户端建立TCP连接请求。在与服务器建立好TCP连接后，客户端向服务器端请求资源，发送HTTP请求报文，服务器端收到请求报文后，将请求内容响应给客户端。完成请求后，TCP的连接就被释放以供其他的请求。在这个过程中，服务器是如何“理解”客户端的请求的，并且是如何响应给客户端的呢？这就是http协议要干的事情，简单来说http协议规定客户端和服务器如何进行交互。特性http协议是==无状态==的，也就是说不管客户端之前是否访问过服务器某一页面或资源，每一次的访问都与第一次访问时相同。这么设置有好有坏，好处是服务器不需要去记录和维护客户端的状态，能支持高并发的请求。坏处是这样简单的设计在一些场景就显得十分不足，比如购物,当服务器无法记录的之前的状态时，那你的购物车的商品就无法保存下来，每一次打开页面购物车都是空的，解决方法是使用cookie来保存状态。http协议是==无连接==的，每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间，但是现在的网页是比较复杂的，如果每次只处理一个请求，单单就连接建立释放就会浪费很多时间和资源，所以后来出现的长连接方式比较好的解决了这个问题。报文结构请求报文：客户端向服务器发送的请求报文响应报文：服务器响应给客户端的回答。请求报文和响应报文是由三部分组成的。请求报文：请求行、请求头部、请求体1、请求行包含了请求的类型，请求资源的路径和http协议版本信息请求类型：下表列举了三种常用的请求类型类型含义GET请求读取URL所标志的信息POST给服务器添加信息HEAD请求读取由URL所标志的信息的头部GET请求是最常用的请求类型，当向服务器请求资源时通过URL来定位，比如https://www.zhihu.com/search?type=content&amp;q=%E8%AE%A1%E7%AE%97%E6%9C%BA 三种请求类型应用场景：请求知乎服务器里的search页面的资源。但是涉及一些登录注册时的相关信息提交时，这种请求类型不安全。POST请求可以将请求的信息封装在请求数据中（GET请求的请求数据部分通常为空），不会在URL暴露给用户。当只需要查看页面的状态时，使用HEAD请求效率会很高，因为它只返回响应头，而不返回页面的内容。注：URI：统一资源标识符，URL：统一资源定位符。URI包括URL和URN。简单来说，URI是通过某一规则来唯一确定某一资源，URL是通过定位（比如主机上资源的路径）来唯一确定某一资源。定位就可以近似看做URI的某一规则中的一种。2、请求头部有很多属性（键值对）组成。常见的有Host（主机域名）、User-Agent（浏览器信息）、Accept-Language（返回内容使用的语言）、Connection（决定执行当前的事务后是否关闭连接）获取更多请求字段信息3、请求数据请求报文里很少使用到这个字段，POST请求可能会常用到。在响应报文里经常用到此字段来返回页面内容。响应报文：状态行、响应头、响应正文1、状态行通过状态码返回访问的状态。状态码状态信息1XX代表请求已被接受，需要继续处理2XX代表请求已成功被服务器接收、理解、并接受3XX代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明4XX代表了客户端看起来可能发生了错误，妨碍了服务器的处理5XX表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理获取更多详细状态码信息2、响应头也是由很多字段组成（键值对）。常见的有content-length（以八位字节数组表示的请求体的长度）、content-type（请求体的 多媒体类型 用于POST和PUT请求中）、date(发送该消息的日期和时间)……获取更多请求字段信息3、响应正文服务器响应给客户端所请求的内容。如：连接建立方式非持续连接：在http1.0版本，对于页面上的每一个链接的请求都需要重新创建一个TCP连接，不仅仅是在时间上延长很多，并且在服务器每次建立连接都要分配缓存和变量，在请求很大的时候，服务器的压力会非常的重。持续连接：在http1.1版本中，使用了持续连接，也就是客户端发送请求服务器响应后仍然可以保持这条连接，在请求头中会带上connection：keep-alive的字段。这么一来在时间和资源上都大大减少。持续连接又分为两种：请求管线化和请求非管线化。非管线化的特点是在前一个请求得到响应后才能发送下一个请求，所以在发送完请求到收到响应这段时间TCP连接是空闲在那的，造成了资源的浪费。而管线化则是可以连续的发送请求，服务器连续响应，很大的提高的利用率和响应效率。http发展http1.1除了在长连接上与1.0版本不同，在缓存方面http1.0是通过条件请求（请求的if-Modified-Since和响应的Last-Modified）的字段来判断缓存是否有效。http1.1加入了ETag来标识URL上的资源的特定版本。在带宽优化方面允许请求资源的某一部分（Content-Range字段实现），新增一个100状态码用来在请求资源前先发送一个只带请求头的请求，这样一来避免在不知道服务器是否会拒绝请求的情况下仍然去发送实体资源的请求，避免了带宽的浪费。http2.0版本在速度上比http1.1快了很多。具体可以参考HTTP1.0、HTTP1.1 和 HTTP2.0 的区别Cookie和Session简述（2018.09.28）Cookie机制之前谈到http协议是无状态的，也就是说每一次访问页面时服务器都把这次请求当作第一次访问，这样就会有很多局限性。Cookie机制很好解决了这个问题。Cookie是一种服务器发给客户端并且存储在客户端的文本文件。如果请求页面时，客户端的请求头没有Cookie信息时，服务器在响应时就会返回一个Set-Cookie头部来创建cookie。Set-Cookie头部的格式为：Set-Cookie: value[; expires=date][; domain=domain][; path=path][; secure] value：是一个name-value的键值对，指定Cookie的值expires：可以设置一个过期时间，如果不设置，那么这个cookie会在浏览器页面关闭时销毁（称为会话Cookie）。domain：cookie所属的域及子域。secure：表示该cookie只能用https传输。一般用于包含认证信息的cookie，要求传输此cookie的时候，必须用https传输。path：cookie的所属路径之后客户端再次访问页面时就会在http请求带上Cookie头部，这样一来服务器就能通过Cookie获取到该用户的状态了。过程如图：但是Cookie是明文传输的，容易被篡改，存在很大的安全隐患，Session机制解决了这个问题。Session机制与Cookie存储在客户端不同的是，Session是存放在服务器上的，但Session机制是基于Cookie上面。其过程是当用户提交一个HTTP请求后，服务器经过验证后将用户信息存放在服务器端，并且返回一个包含key为Session ID的键值对的Cookie。客户端保存这个Session ID，以后的HTTP请求只要带上Session ID即可。因为用户信息是存放在服务器上，对用户来说是透明的，大大减少了明文篡改造成的安全威胁。如果客户端禁用Cookie，就会采用URL方式带上Session ID。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>cookie</tag>
        <tag>session</tag>
        <tag>http协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合项目练习]]></title>
    <url>%2Fspringboot(%E4%B8%80).html</url>
    <content type="text"><![CDATA[一个SpringBoot整合项目练习，使用到的技术Mybatis+Druid+PageHelper+Swagger2+thymeleaf，采用RESTful的url风格。项目简介练习项目的主要技术如下：SpringBoot 2.0.4Mybatis 1.3.2Druid 1.1.8PageHelper 1.2.5Swagger2 2.6.1thymeleaf按照个人理解简单介绍下这几个技术的功能SpringBoot就是对Spring框架的一个优化，在配置方面进行比较大的优化。减少了很多的底层配置，大量的注解开发避免了xml配置的繁琐。 MyBatis是一个持久层框架，可以将POJOs直接与数据库的记录进行映射。以前的JDBC需要将SQL语句写进Java代码中，而且需要在结果集上遍历然后进行映射，比较繁琐。而MyBatis优化了这些步骤，它将结果集可以直接与POJO进行映射，并且将sql语句通过xml或注解进行配置。 Druid是阿里巴巴开发的一个数据库系统，不仅提供了强大的数据库监控功能，而且可以作为一个数据库连接池，性能方面非常优秀。 PageHelper是一款Mybatis的分页插件，通过拦截器获取到同一线程的SQL语句，然后包装成有分页功能的SQL语句。PageInfo封装了很多分页的信息。 Swagger2可以高效的帮助我们生成业务接口的文档，如果项目有些业务逻辑修改了，也会自动更新成新的文档。 项目实现导入依赖版本管理&lt;properties> &lt;project.build.sourceEncoding>UTF-8&lt;/project.build.sourceEncoding> &lt;project.reporting.outputEncoding>UTF-8&lt;/project.reporting.outputEncoding> &lt;java.version>1.8&lt;/java.version> &lt;mybatis-springboot.version>1.3.2&lt;/mybatis-springboot.version> &lt;swagger2.version>2.6.1&lt;/swagger2.version> &lt;mysql.version>5.1.46&lt;/mysql.version> &lt;druid.version>1.1.8&lt;/druid.version> &lt;pagehelper-springboot.version>1.2.5&lt;/pagehelper-springboot.version> &lt;/properties> 相关依赖&lt;!--Mybatis相关依赖--> &lt;dependency> &lt;groupId>org.mybatis.spring.boot&lt;/groupId> &lt;artifactId>mybatis-spring-boot-starter&lt;/artifactId> &lt;version>${mybatis-springboot.version}&lt;/version> &lt;/dependency> &lt;!--Swagger2--> &lt;dependency> &lt;groupId>io.springfox&lt;/groupId> &lt;artifactId>springfox-swagger-ui&lt;/artifactId> &lt;version>${swagger2.version}&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>io.springfox&lt;/groupId> &lt;artifactId>springfox-swagger2&lt;/artifactId> &lt;version>${swagger2.version}&lt;/version> &lt;/dependency> &lt;!--mysql数据库依赖--> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;/dependency> &lt;!-- alibaba的druid数据库连接池 --> &lt;dependency> &lt;groupId>com.alibaba&lt;/groupId> &lt;artifactId>druid&lt;/artifactId> &lt;version>${druid.version}&lt;/version> &lt;/dependency> &lt;!--分页插件--> &lt;dependency> &lt;groupId>com.github.pagehelper&lt;/groupId> &lt;artifactId>pagehelper-spring-boot-starter&lt;/artifactId> &lt;version>${pagehelper-springboot.version}&lt;/version> &lt;/dependency> &lt;!--热部署--> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-devtools&lt;/artifactId> &lt;/dependency> &lt;!--模板引擎--> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-thymeleaf&lt;/artifactId> &lt;/dependency> mybatis逆向工程插件配置&lt;plugin> &lt;groupId>org.mybatis.generator&lt;/groupId> &lt;artifactId>mybatis-generator-maven-plugin&lt;/artifactId> &lt;version>${mybatis-springboot.version}&lt;/version> &lt;configuration> &lt;configurationFile>${basedir}/src/main/resources/generator/generatorConfig.xml&lt;/configurationFile> &lt;overwrite>true&lt;/overwrite> &lt;verbose>true&lt;/verbose> &lt;/configuration> &lt;dependencies> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;version>${mysql.version}&lt;/version> &lt;/dependency> &lt;/dependencies> &lt;/plugin> 配置文件全局配置文件server: port: 8080 spring: datasource: url: jdbc:mysql://localhost:3306/mybatis_druid?userUnicode=true&amp;characterEncoding=utf8 username: root password: 1234 driver-class-name: com.mysql.jdbc.Driver #配置类型为Druid数据库连接池 type: com.alibaba.druid.pool.DruidDataSource initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙 filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 thymeleaf: cache: false mybatis: #配置映射文件的路径 mapperLocations: classpath:mapper/*.xml typeAliasesPackage: me.freelee.mybatisdruid.model configLocation: classpath:mybatis-config.xml mybatis配置文件&lt;?xml version="1.0" encoding="UTF-8"?> &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"> &lt;configuration> &lt;settings> &lt;!-- 全局启用或禁用延迟加载。禁用后，所有关联对象都会即使加载 --> &lt;setting name="lazyLoadingEnabled" value="true" /> &lt;!-- 使用驼峰命名法--> &lt;setting name="mapUnderscoreToCamelCase" value="true" /> &lt;/settings> &lt;/configuration> mybatis逆向工程配置文件&lt;?xml version="1.0" encoding="UTF-8"?> &lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"> &lt;generatorConfiguration> &lt;context id="DB2Tables" targetRuntime="MyBatis3"> &lt;commentGenerator> &lt;property name="suppressDate" value="true"/> &lt;!--是否去除自动生成的注释--> &lt;property name="suppressAllComments" value="true"/> &lt;/commentGenerator> &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://localhost:3306/mybatis_druid" userId="root" password="1234">&lt;/jdbcConnection> &lt;javaTypeResolver> &lt;property name="forceBigDecimals" value="false"/> &lt;/javaTypeResolver> &lt;!-- 生成模型的包名和位置--> &lt;javaModelGenerator targetPackage="me.freelee.mybatisdruid.model" targetProject="src/main/java"> &lt;property name="enableSubPackages" value="true"/> &lt;property name="trimStrings" value="true"/> &lt;/javaModelGenerator> &lt;!-- 生成映射文件的包名和位置--> &lt;sqlMapGenerator targetPackage="mapper" targetProject="src/main/resources"> &lt;property name="enableSubPackages" value="true"/> &lt;/sqlMapGenerator> &lt;!-- 生成DAO的包名和位置--> &lt;javaClientGenerator type="XMLMAPPER" targetPackage="me.freelee.mybatisdruid.mapper" targetProject="src/main/java"> &lt;property name="enableSubPackages" value="true"/> &lt;/javaClientGenerator> &lt;table tableName="tb_user" domainObjectName="User" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false">&lt;/table> &lt;/context> &lt;/generatorConfiguration> 接下来运行mybatis-generator插件，就会生成数据库指定表对应的model和mapper。业务逻辑UserService接口的实现类（只贴出了关键方法）。@Override public PageInfo&lt;User> queryPage(Integer pageNum) { //引入PageHelper分页插件 //startPage方法后紧跟查询语句,这样才能实现分页查询 PageHelper.startPage(pageNum,2); List&lt;User> list=userMapper.selectAllUser(); //PageInfo构造函数第二个参数是显示导航页的数量 PageInfo&lt;User> pageInfo=new PageInfo&lt;>(list,2); return pageInfo; } /* 因为是对数据库进行写操作，所以需要保持原子性。添加了事务的注解@Transactional Propagation.REQUIRED:存在事务就处于当前事务中，没有就才创建一个事务 */ @Transactional(propagation = Propagation.REQUIRED,readOnly = false) public void insertUser(User user) { userMapper.insertSelective(user); } Druid配置类 Druid文档 //导入配置文件中的数据源配置封装成DruidDateSource，并加入到容器中 @ConfigurationProperties(prefix = "spring.datasource") @Bean public DataSource druid(){ return new DruidDataSource(); } //配置Druid的监控 //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet(){ ServletRegistrationBean bean=new ServletRegistrationBean(new StatViewServlet(),"/druid/*"); Map&lt;String,String> initParams=new HashMap&lt;>(); //设置控制台管理用户 initParams.put("loginUsername","admin"); initParams.put("loginPassword","123456"); initParams.put("allow","");//默认就是允许所有访问 bean.setInitParameters(initParams); return bean; } //2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter(){ FilterRegistrationBean bean=new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String> initParams=new HashMap&lt;>(); //不进行过滤的格式 initParams.put("exclusions","*.js,*.css,/druid/*"); bean.setInitParameters(initParams); //设置过滤器过滤路径 bean.setUrlPatterns(Arrays.asList("/*")); return bean; } UserController部分代码 //根据用户Id查询用户 @GetMapping("/{id}") @ResponseBody public User selectUserById(@PathVariable("id") Integer id){ User user=userService.selectUserById(id); return user; } //分页查询所有数据 @GetMapping("") public String list(@RequestParam(value = "pageNo",defaultValue = "1") Integer pageNo , Model model){ PageInfo&lt;User> pageInfo=userService.queryPage(pageNo); model.addAttribute("pageInfo",pageInfo); return "list"; } 现在就可以启动SpringBoot，进行测试了。localhost:8080/druid就可以进入Druid监控系统，可以查看数据源的详细信息等等很多功能。User的分页显示，页面的UI不是很关键，能用就行。还有最后一个步骤，使用Swagger2生成文档。 Swagger2文档首先配置一个Swagger2的配置类：@EnableSwagger2：开启swagger2注解功能@Configuration @EnableSwagger2 public class SwaggerConfig { //创建一个Docket对象包含以下信息： // 1、Api的详细信息，即apiInfo（） // 2、指定需要生成文档的包路经 // 3、指定生成Api文档的路径 @Bean public Docket createRestApi(){ return new Docket(DocumentationType.SWAGGER_2) //apiInfo（）创建接口文档的信息 .apiInfo(apiInfo()) .select() //api（）可以控制指定扫描包下定义的Api暴露给Swagger2 .apis(RequestHandlerSelectors.basePackage("me.freelee.mybatisdruid.controller")) .paths(PathSelectors.any()) .build(); } //构建Api文档的相信信息 private ApiInfo apiInfo(){ return new ApiInfoBuilder() .title("使用Swagger2构建RESTful APIs") .description("Springboot REST API With Swagger2") .version("1.0") .build(); } } 还需要再Controller上添加Swagger2注解。@Api：用来标注类。Swagger2会检测标注此注解的类@ApiOperation：用来标注方法，会将此方法暴露给Swagger2来生成文档。value：方法名 notes：方法的描述 除此之外，还有@ApiImplicitParam可以标注方法参数，可以设定是否required，名称，类型……如果不想把接口暴露给Swagger2，可以使用@ApiIngore标注方法。@Api(value = "用户Controller") @Controller @RequestMapping("/user") public class UserController { @Autowired UserService userService; @ApiOperation(value = "获取用户信息", notes = "根据用户id获取用户信息") @ApiImplicitParam(name = "id",value = "用户的ID",required = true,dataType = "Integer") @GetMapping("/{id}") @ResponseBody public User selectUserById(@PathVariable("id") Integer id){ User user=userService.selectUserById(id); return user; } @ApiOperation(value = "获取用户列表", notes = "获取用户列表") @GetMapping("") public String list(@RequestParam(value = "pageNo",defaultValue = "1") Integer pageNo , Model model){ PageInfo&lt;User> pageInfo=userService.queryPage(pageNo); model.addAttribute("pageInfo",pageInfo); return "list"; } } Swagger2文档主页面如图，可以看到我们含有注解@ApiOperation的方法显示再文档中。点击其中一个方法,可以看到我们设置的一些信息。文档提供了一个Model的一个值的示例，服务器相应类型包括所有返回类型。然后下面是方法的参数，输入对应类型的值，点击Try it out！会进行对服务器的请求（如果是写入操作，会写入数据库），就能得到Request Url和Response Body等其他详细信息。项目中遇到的问题已解决：1、pagehelper的依赖问题，会导致PageInfo对象无法自动装配。 错误依赖 &lt;dependency> &lt;groupId>com.github.pagehelper&lt;/groupId> &lt;artifactId>pagehelper&lt;/artifactId> &lt;version>5.1.2&lt;/version> &lt;/dependency> 正确依赖 &lt;dependency> &lt;groupId>com.github.pagehelper&lt;/groupId> &lt;artifactId>pagehelper-spring-boot-starter&lt;/artifactId> &lt;version>${pagehelper-springboot.version}&lt;/version> &lt;/dependency> 未解决：1、在selectUserById（）加上注解后 @ApiImplicitParam(name = &quot;id&quot;,value = &quot;用户的ID&quot;,required = true,dataType = &quot;Long&quot;) ，使用Swagger2测试时，会报错 *&quot;Failed to convert value of type &#39;java.lang.String&#39; to required type &#39;java.lang.Long&#39;; nested exception is java.lang.NumberFormatException: For input string: \&quot;{id}\&quot;&quot;,* 不知道在传参过程为什么不会自动类型转换？？？2、thymeleaf作为模板引擎时，想构建DELETE请求和PUT请求，尝试过ajax方式，但是失败了目前找不到错误在哪，其他方法还未尝试。 参考文章链接Spring Boot中使用Swagger2构建强大的RESTful API文档主流Java数据库连接池比较及前瞻完整代码github：https://github.com/LJP-Perfect/SpringBoot_Project码云：https://gitee.com/free-lee/springboot_project_practice]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>MyBatis</tag>
        <tag>Swagger2</tag>
        <tag>Druid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList]]></title>
    <url>%2FArrayList.html</url>
    <content type="text"><![CDATA[今天写Java集合框架里的其中一种容器——ArrarList。听上去跟数组差不多，其实，它们很多理念上是真差不多。先放一张集合框架图。乍一看，感觉贼复杂，头要炸。其实只要小小分析一波，就不会觉得难了。要不，我再放一张简化图？！简化图里把重点都给留下了。从上面那张框架图中可以看出ArrayList是一个实现类，继承了AbstarctList抽象类，实现了List接口，我们可以从源码中看到这些，除了这些，ArrayList还实现了RandomAccess，Cloneable，Serializable这三个接口。简单介绍一下这三个接口（等学深了，再来给详细的）。RandomAccess翻译一下，就是随机访问，这就像数组那样可以通过下标直接访问那个元素。Cloneable克隆接口，其可以将一个实例拷贝到一个新实例。实际上只拷贝其中的各变量的值，是浅拷贝。Serializable可序列化接口，通过此接口可以实现实例的存储，使用时可以通过反序列化得到那个实例。ArrayList的本质就是一个Object对象类型的数组，在这个数组上进行一系列操作，因为Object是所有类的基类，所以可以接收任意同类型的对象。并且用到了泛型，可以自己指定对象的类型。ArrayList的初始化1、静态初始化(在声明变量时，赋予初始值。)//第一种 public static void main(String[] args) { ArrayList&lt;String&gt; arraylist=new ArrayList&lt;String&gt;(){ { add(&quot;a&quot;); add(&quot;b&quot;); } }; } //第二种 public static void main(String[] args) { ArrayList&lt;String&gt; arraylist=new ArrayList&lt;String&gt;(Arrays.asList(&quot;a&quot;,&quot;b&quot;)); System.out.print(arraylist); } //第三种 public static void main(String[] args) { String[] str={&quot;a&quot;,&quot;b&quot;}; List arraylist=Arrays.asList(str); } 要注意的是，第三种的arraylist是无法改变其长度的，即无法进行add(),remove()等操作，因为数组一旦给定，长度就无法改变，初始化时将数组泛型化赋给它。2、动态初始化public static void main(String[] args) { ArrayList&lt;String&gt; arraylist=new ArrayList&lt;String&gt;(); arraylist.add(&quot;a&quot;); arraylist.add(&quot;b&quot;); System.out.println(arraylist); } ArrayList 常用方法讲完了初始化，来看一下ArrayList的一些常用方法。1、add()我们先来看看add()方法的源码 public boolean add(E e) { modCount++; add(e, elementData, size); return true; } 可以看到这里的add()又调用了与它互为重载的方法，如下。 /** * This helper method split out from add(E) to keep method * bytecode size under 35 (the -XX:MaxInlineSize default value), * which helps when add(E) is called in a C1-compiled loop. */ private void add(E e, Object[] elementData, int s) { if (s == elementData.length) elementData = grow(); elementData[s] = e; size = s + 1; } 可以看到如果当前数组的长度等于当前设定的size就会调用grow()方法。size不用多讲，就是ArrayList包含的元素个数，来看一下elementData和grow()的定义。先看elementDate，其本质是一个对象数组。如果创建一个空的ArrayList时，系统会将其capacity置 为10,也就是默认的大小为10。 transient Object[] elementData; // non-private to simplify nested class access 然后在看grow()。它也去调用了与它重载的方法，可以看到它将size+1值传给重载函数，带参函数将其扩展成当前数组大小的两倍。private Object[] grow(int minCapacity) { return elementData = Arrays.copyOf(elementData, newCapacity(minCapacity)); } private Object[] grow() { return grow(size + 1); } 再回到add()，如果数组长度与当前数组容量相同，则先扩增一倍大小，然后赋值。还没讲完呢，add()还有另外一个重载方法（我的天哪，一个add()的源码比我想象的要多）。 public void add(int index, E element) { rangeCheckForAdd(index); modCount++; final int s; Object[] elementData; if ((s = size) == (elementData = this.elementData).length) elementData = grow(); System.arraycopy(elementData, index, elementData, index + 1, s - index); elementData[index] = element; size = s + 1; } 这个add()方法接受外部两个参数，index就是要添加的位置的下标。首先rangeCheckForAdd(),是判断index是否合法的（大于等于0&amp;&amp;小于等于size，注意add时，不能跨长度给它赋值）,modCount是记录此数组修改的次数，（这里又可以展开很多知识，我直接抛一个链接https://www.cnblogs.com/zuochengsi-9/p/7050351.html），其主要就是防止线程安全的ArrayList一边用iterator遍历时一边对ArrayList进行增删操作时发生异常。然后是arraycopy()，查看源码时发现它是native（C++真厉害）,那就看声明，其意思就是将从src里的srcPos位置开始的length长度赋给从destPos位置的dest。public static native void arraycopy(Object src, int srcPos, Object dest,int destPos,int length); 再来看看具体使用。 ArrayList &lt;String&gt;arraylist = new ArrayList&lt;String&gt;(); arraylist.add(&quot;b&quot;); arraylist.add(0,&quot;a&quot;); arraylist.add(2,&quot;c&quot;) //下标为3的地方还为null //arraylist.add(4,&quot;d&quot;); //error System.out.println(arraylist); Output： [a, b, c] 这里a和b的位置是因为arraycopy。2、remove()remove()也有两个重载方法。就不贴源码了，源码哪都可以查到。//按照下标来移除 public E remove(int index); //按照元素来移除 public boolean remove(Object o); //clear()方法是删除所有元素 public void clear() //删除指定下标范围的元素 protected void removeRange(int fromIndex, int toIndex) 如果使用remove删除某个下标是ArrayList的中间一个元素，那么ArrayList会将所删元素后面的元素前移一个位置。ArrayList与Array那不是有数组就可以了吗？为什么还要ArrayList呢？| | ArrayList | Array || ——– | :—–: | :—-: || 可扩展性 | 可以动态改变其长度 | 数组是静态的，一旦长度给定，就无法改变 || 方法支持 | 有很多的方法可以方便的对ArrayList进行操，但是牺牲了效率(判定数组是否outBounds…) | 数组没有 |总之，各有各的优点，选用哪种也是视具体情况而定的，并无绝对的说法。`]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>Java容器</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ng课程完结篇]]></title>
    <url>%2FNG.html</url>
    <content type="text"><![CDATA[从4月2号开始学习Ng的机器学习，没有给我难以入门的感觉，虽然很多模型都没有用很深的公式去推导，但是真的很好理解，很适合我这种小白啊。不得不佩服恩达大佬的教学能力，不过感觉1.25倍速对我来说简直灾难啊，还是老老实实1倍吧(渣渣鉴定完毕)。看到最后，莫名感动，以泪谢幕。为了赶项目进度，只能放弃算法的深入推导，先大致理解模型及参数的作用，接着就是开始学习NLP。可，没有明确的学习方向和路线啊，感觉GG。还得先啃点公开课，原理还是要懂的，coding能力很是让我难受，得实践实践了。时间不够用啊，7月就是结项目，哇得就哭出来了。不说了，继续视频feed。]]></content>
      <categories>
        <category>ML</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu安装及常见问题解决]]></title>
    <url>%2Fubuntu.html</url>
    <content type="text"><![CDATA[搬自自己的csdnUbuntu——从安装到放弃（/逃 ）【此教程包括ubuntu的安装、关机卡死（Nvidia安装）、无法连接wifi等解决方案】]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu下配置tensorflow(gpu)]]></title>
    <url>%2Ftensorflow.html</url>
    <content type="text"><![CDATA[搬自自己的csdnUbuntu16.04环境下从Anaconda3安装到Tensorflow(gpu)及pycharm安装和测试mnist完整教程]]></content>
      <categories>
        <category>ML</category>
      </categories>
      <tags>
        <tag>anaconda</tag>
        <tag>tensorflow配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性回归之波士顿房价预测]]></title>
    <url>%2FLinear_Regression.html</url>
    <content type="text"><![CDATA[最近学习了线性回归，然后拿经典数据集来练习。数据集大小为[506,13],一共506个样本，13个特征([‘CRIM’ ‘ZN’ ‘INDUS’ ‘CHAS’ ‘NOX’ ‘RM’ ‘AGE’ ‘DIS’ ‘RAD’ ‘TAX’ ‘PTRATIO’ ‘B’ ‘LSTAT’])，target大小为[506，1]可以先通过matplotlib来直观感受这些特征分别与房价的关系。为了简化训练，只选择了第6个特征[‘RM’]来训练（第6个和最后一个特征的直观看上去比较符合线性回归），13个特征只在506个样本下比较难去拟合好。下面是代码解释#import data boston=load_boston() data=boston.data[:,(5)] label=boston.target #reshape column vector data=data.reshape(-1,1) label=label.reshape(-1,1) 因为这里我们只导入一列数据，我们需要把 [ ] reshape为[[ ]]，否则会报以下错误Reshape your data either using array.reshape(-1, 1) if your data has a single feature or array.reshape(1, -1) if it contains a single sample.接下来，对特征数据做特征缩放（对于单个特征来说，特征缩放的作用并不是特别大，但习惯起见，还是对其进行特征缩放，但是在多特征中，特征缩放显得尤其重要，可以加快梯度下降，见图）接下来就是定义一些占位符和权值、偏置等变量偏置初始化0即可，权值最好不要初始化为0，使用正太分布随机值，如果使用0去初始化权值。在反向传播计算会出现不同权值变化量始终相同从而导致权值更新出现异常（推导见图）。#getting number of training set &amp; number of feature m_feature=data.shape[1] m_train=tf.placeholder(dtype=tf.float32) x=tf.placeholder(dtype=tf.float32,shape=[None,m_feature],name=&#39;input&#39;) y_=tf.placeholder(dtype=tf.float32,shape=[None,1],name=&#39;output&#39;) #Define weights and offsets viriables #Initialize weights using a Gaussian distribution #Initialize the bias to 0 w=tf.Variable(tf.truncated_normal(shape=[m_feature,1],stddev=0.003,dtype=tf.float32)) b=tf.Variable(tf.zeros(shape=[1],dtype=tf.float32)) 然后就是前向计算和反向计算，这个没有什么好说的，注意cost function的选择即可#Forward calculation y=tf.add(tf.matmul(x,w),b) #use the mean square error function learn_rate=0.08 loss=tf.reduce_sum(tf.pow(y_-y,2)/(2*m_train)) train_step=tf.train.GradientDescentOptimizer(learn_rate).minimize(loss) 这里我们定义一个list来存储训练过程中的loss值，再定义一个张量error来简单评估测试的误差#variable train_loss is used to save the loss value of each iteration train_loss =[] #error error = tf.reduce_mean(y-y_) 然后就开始进行训练这里的重点在于数据集的划分，一开始用的是train_test_split将数据集划分成两份，70%为训练集，30%为测试集。但是听取别人建议后，使用k折交叉验证法。所谓k折交叉验证法，就是将数据集分成k份，每次取其中k-1份作为训练集，另外1份作为测试集，这样的好处是所有数据都有被利用，可以得到更好的参数，但是耗时会长一点（见图）。with tf.Session() as sess: sess.run(init) for i in range(150): #k-fold cross validation kf=KFold(n_splits=10) for train_index,test_index in kf.split(data): X_train,X_test=data[train_index],data[test_index] Y_train,Y_test=label[train_index],label[test_index] w_,b_,_,l=sess.run(fetches=[w,b,train_step,loss], feed_dict={x: X_train, y_: Y_train,m_train:X_train.shape[0]}) if i%10==0: print(&quot;Epoch {0} : error:{1}&quot;.format(i,sess.run(error,feed_dict={x:X_test,y_:Y_test}))) train_loss.append(l) #print(&quot;Epoch {0} : loss{1}&quot;.format(i, l)) 我用两种方法进行比较，首先是k（取10）折交叉验证的结果然后是train_test_split分类方法的结果还是可以比较明显的看到，不管是loss值还是拟合程度。明显都是k折交叉验证法效果比较好。完整代码请参考：https://github.com/LJP-Perfect/Machine-Learning/tree/master/Linear%20Regression总结几点：1、对特征进行选取2、多特征时进行特征缩放3、选取合适的cost function4、使用k折交叉验证还未解决的问题：1、初始数据的分析2、学习速率和k值的选取3、选择更好的cost function]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>feature scaling</tag>
        <tag>boston price</tag>
        <tag>bp算法</tag>
        <tag>k折交叉验证</tag>
        <tag>线性回归</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析SVM之概念介绍]]></title>
    <url>%2FSVM.html</url>
    <content type="text"><![CDATA[简单例子先从一个简单的例子开始。现在有一组两个类别的数据如下。这是一个比较简单的二分类问题，对于这一组数据，这个超平面可以用以下函数来表示：(超平面是从n维空间到n-1维空间的一个映射子空间，它有一个n维向量和一个实数定义)$$w\cdot x+b=0 \qquad (1) $$分类决策函数表示为$$f(x)=sign(w\cdot x+b)$$即在超平面上的点f(x)=0，f(x)大于0的点对应y=1,f(x)小于0的点对应y=-1。注:sign函数为符号函数,当sign(t)中的t&gt;0时，sign(t)=1;t&lt;0时，sign(t)=-1;t=0时，sign(t)=0。在逻辑回归的hypotheis function中，当$\theta\cdot x$ &gt;0时，输出y=1；当$\theta\cdot x$ &lt;0，输出y=0。在这里我们首先将$\theta\cdot x$ 表示成$w\cdot x+b$ (其实就是将$\theta_{0}$从$\theta$向量中抽离出来表示成b)，同时将y=0和y=1表示为y=1和y=-1(对于结果并不会产生影响)。再回到分问题，对于这个二分类问题可以有很多个不同的超平面来对其分割，如下图。但是这么多条decision boundary，总是有performance好的和不好的，如何找出最优的解呢？表现评估标准函数间隔和几何间隔对于上面的三个超平面可以很自然的得出直线所对应的是较好的，很直观得可以看到它与两个类别中与其最近的点对应的距离较大，而且这条直线对一些outlier的表现也比较好，即泛化能力。所以引入函数间隔来进行衡量。函数间隔的含义就是表示分类的正确性及确信度，对于距离超平面较远的样本，其预测的确信度较高，反之距离较远的样本，其预测的确信度较低。对于给定的某个样本点($x_{i}$,$y_{i}$),我们定义超平面关于该样本点的函数间隔为$$\hat\gamma_{i}=y_{i}(w{\cdot}x_{i}+b)\qquad (2)$$那么在所有样本中的最小函数间隔就为$$\hat{\gamma}=min\ \hat\gamma_{i},i=1,…,N\qquad (3)$$虽然函数间隔可以表示分类预测的确信度，但是它是相对的。如果我们成比例的改变w和b，超平面并没有改变，但是函数间隔却变成了原来的两倍。这时可以使用几何间隔来替换函数间隔。几何间隔也就是样本到超平面的几何距离，记作$\gamma_{i}$,$$\gamma_{i}=y_{i}(\frac {w}{||w||} {\cdot}x_{i}+ \frac {b}{||w||})\qquad (4)$$||w||为w的$L_{2}$范数，其中$y_{i}$表示了$y_{i}$等与1和-1的情况。那么在所有样本中的最小几何间隔就为$${\gamma}=min\ {\gamma}_{i}, i=1,…,N\qquad (5)$$间隔最大化根据上面(5)，可以将最大化问题表示下面的约束最优化问题：$$max\ \gamma\qquad(6)$$$$s.t.\quad y_{i}(\frac {w}{||w||} {\cdot}x_{i}+ \frac {b}{||w||})\geq\gamma,\ i=1,2,…,N\qquad(7)$$根据(2)~(5)，可以推出$$\gamma_{i}=\frac {\hat\gamma_{i}}{||w||}\qquad (8)$$$$\gamma=\frac{\hat\gamma}{||w||}\qquad (9)$$根据(9)，求解(6)的问题就可以转化成$$max\;\frac{\hat\gamma}{||w||}\qquad(10)$$$$s.t.\quad y_{i}(\frac {w}{||w||} {\cdot}x_{i}+ \frac {b}{||w||})\geq\gamma,\ i=1,2,…,N\qquad(11)$$在之前的推导过程中提到过对w和b按比例进行放大缩小对求解并不会产生影响，所以得到从函数间隔到几何间隔的转化。现在也是一样，将w和b进行缩放，也就是对$\hat\gamma$进行缩放，对求解结果同样也不会产生影响，所以我们取$\hat\gamma=1$，进行这一步主要是简化之后的数学计算。此时问题转化为$max\;\frac{1}{||w||}$,而$\frac{1}{||w||}$ 正好是几何间隔。进一步可以发现最大化$\frac{1}{||w||}$ 和最小化$\frac{1}{2}||w||^{2}$ 是等价的，至此(10)就转换成以下的最优化问题：$$min\ \frac{1}{2}\ ||w||^{2}\qquad(12)$$$$s.t.\quad y_{i}(\frac{w}{||w||}\cdot x_{i}+ \frac {b}{||w||})-1\geq0,i=1,2,…,N\qquad(13)$$ ,这是一个凸二次规划问题(凸二次规划详细内容链接)。只要解出$w^{\ast}$ 和$b^{\ast}$ 即可得到超平面$w^{\ast}\cdot x+b^{\ast}=0$ 和分类决策函数$f(x)=w^{\ast}\cdot x+b^{\ast}$ 。几何间隔的直观化如下图，最终就是要使margin最大化的一个问题(负样本和正样本的margin应是一样的)。下图中两条虚线到直线的距离均为$\frac{1}{||w||}$，定义在虚线上的点称为支持向量(Support vector)。$w^{\ast}$ 和$b^{\ast}$ 的求解过程中其实只会受支持向量的影响，为什么呢？在之后的一篇数学推导会给出证明。到这里，对SVM应该有了一个简单的认识。总的来说，SVM就是要找出一个超平面，使两类样本点中所有距离它最近的点，都尽可能的离它远。To be continue]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>margin</tag>
        <tag>hypeplane</tag>
        <tag>classfication</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fbaidu_verify_w2CJZAKCk7.html</url>
    <content type="text"><![CDATA[w2CJZAKCk7]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fbaidu_verify_D4umA77Wgx.html</url>
    <content type="text"><![CDATA[D4umA77Wgx]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fbaidu_verify_PQgHckNDnk.html</url>
    <content type="text"><![CDATA[PQgHckNDnk]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fgooglea4979d339ced872b.html</url>
    <content type="text"><![CDATA[google-site-verification: googlea4979d339ced872b.html]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F581%2Findex.js</url>
    <content type="text"><![CDATA[var svg=document.querySelector("svg"),cursor=svg.createSVGPoint(),arrows=document.querySelector(".arrows"),randomAngle=0,target={x:900,y:249.5},lineSegment={x1:875,y1:280,x2:925,y2:220};function knock(e){randomAngle=Math.random()*Math.PI*.03-.015,TweenMax.to(".arrow-angle use",.3,{opacity:1}),window.addEventListener("mousemove",aim),window.addEventListener("mouseup",loose),aim(e),TweenMax.to("#arc",.3,{opacity:1})}function loose(){window.removeEventListener("mousemove",aim),window.removeEventListener("mouseup",loose),TweenMax.to("#bow",.4,{scaleX:1,transformOrigin:"right center",ease:Elastic.easeOut}),TweenMax.to("#bow polyline",.4,{attr:{points:"88,200 88,250 88,300"},ease:Elastic.easeOut});var e=document.createElementNS("http://www.w3.org/2000/svg","use");e.setAttributeNS("http://www.w3.org/1999/xlink","href","#arrow"),arrows.appendChild(e);var t=MorphSVGPlugin.pathDataToBezier("#arc");TweenMax.to([e],.5,{force3D:!0,bezier:{type:"cubic",values:t,autoRotate:["x","y","rotation"]},onUpdate:hitTest,onUpdateParams:["{self}"],onComplete:onMiss,ease:Linear.easeNone}),TweenMax.to("#arc",.3,{opacity:0}),TweenMax.set(".arrow-angle use",{opacity:0})}function hitTest(e){var t=e.target[0]._gsTransform,a=t.rotation*Math.PI/180,n=getIntersection({x1:t.x,y1:t.y,x2:60*Math.cos(a)+t.x,y2:60*Math.sin(a)+t.y},lineSegment);if(n.segment1&&n.segment2){e.pause();var o=n.x-target.x,r=n.y-target.y,s=".hit";Math.sqrt(o*o+r*r)=0&&w=0&&x]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F581%2Fstyle.css</url>
    <content type="text"><![CDATA[body{margin:0;background:#222;margin:20px}svg{width:100%;height:100%;position:fixed;top:0;left:0}span{color:#fff;font-family:sans-serif;opacity:.3}]]></content>
  </entry>
  <entry>
    <title><![CDATA[Who am I]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[关于我浙江理工大学 计算机专业大三在读轻度中二，轻度社交恐惧偏爱简约，喜欢生活充满新鲜感会点Java，目前正在学习搭建后台项目联系我Mail：871560465@qq.comSteam：Freelee（一起Play Game啊）github：https://github.com/LJP-Perfect]]></content>
  </entry>
  <entry>
    <title><![CDATA[games]]></title>
    <url>%2Fgames%2Findex.html</url>
    <content type="text"><![CDATA[L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":75,"height":150,"scaling":2,"horizontalOffset":10,"verticalOffset":-40},"mobile":{"show":false,"Scaling":0.5},"log":false,"tagMode":false}); window.ityped.init(document.querySelector(‘.ityped’), { strings : [‘ 网瘾少年(女)们，快玩游戏吧’], //可以写无限条句子，只要用逗号隔开 typeSpeed: 155, //打字的速度 backSpeed: 60, //删除字的速度 startDelay: 500, //每一句开始打字停顿的时间 backDelay: 2500, //每一句删除字的停顿时间 loop: false, //是否循环动画 showCursor: true, //是否显示光标 cursorChar: “︳”, //设置光标字符 });#Bullseye]]></content>
  </entry>
  <entry>
    <title><![CDATA[图库]]></title>
    <url>%2Fgallery%2Findex.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[timeline]]></title>
    <url>%2Ftimeline%2Findex.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
